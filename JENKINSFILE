pipeline {
  agent any

  stages {
    stage('Get Code') {
      steps {
        checkout([
          $class: 'GitSCM',
          branches: [[name: '*/develop']],
          userRemoteConfigs: [[
            url: 'git@github.com:PabloBin/todo-list-aws.git',
            credentialsId: 'github-deploykey'
          ]]
        ])
        sh 'echo "Branch:" && git branch -a --contains HEAD'
        sh 'echo "Last commit:" && git log -1 --oneline'
      }
    }
       
    stage('Static Test') {
      steps {
        sh '''
          # -e: si algo falla, aborta
          # -u: error si usas variables no definidas
          # -x: muestra comandos en el log
          set -eux
    
          # 1) VENV reutilizable (evita reinstalar Python tools en cada build si el workspace se mantiene)
          if [ ! -d ".venv" ]; then
            python3 -m venv .venv
          fi
          . .venv/bin/activate
          
          # 2) Dependencias necesarias para Static Test. Instalar/actualizar herramientas dentro del venv
          pip install --upgrade pip
          pip install flake8 bandit
    
          # 3) Carpeta de reportes 
          mkdir -p reports
          # 4) Solo borramos los reportes de Flake8 y Bandit
          rm -f reports/flake8.out reports/bandit.out
    
          # 5) Flake8 (solo src, no bloqueante, salida estándar a fichero)
          flake8 --exit-zero src > reports/flake8.out
    
          # 6) Bandit (solo src, no bloqueante, salida “custom” para que pyLint lo pinte)
          bandit --exit-zero -r src \
            -f custom -o reports/bandit.out \
            --msg-template "{abspath}:{line}: [{test_id}] {msg}"
        '''
    
        // Publicación de resultados en Jenkins (sin quality gates => build SUCCESS siempre)
        recordIssues(tools: [flake8(name: 'Flake8', pattern: 'reports/flake8.out')])
        recordIssues(tools: [pyLint(name: 'Bandit', pattern: 'reports/bandit.out')])
      }
    }

    stage('Deploy') {
      steps {
        sh '''
          set -eux
    
          # Verificar que hay credenciales en la EC2
          aws sts get-caller-identity
    
          sam --version
    
          sam build
    
          # Deploy no interactivo usando el config-env staging
          sam deploy \
            --config-env staging \
            --no-confirm-changeset \
            --no-fail-on-empty-changeset
        '''
      }
    }

    stage('Rest Test') {
      steps {
        sh '''
          set -eux
    
          # 1) VENV reutilizable (evita reinstalar Python tools en cada build si el workspace se mantiene)
          if [ ! -d ".venv" ]; then
            python3 -m venv .venv
          fi
          . .venv/bin/activate
    
          # 2) Dependencias necesarias para Rest Test. Instalar/actualizar herramientas dentro del venv
          pip install --upgrade pip
          pip install -r src/requirements.txt
          pip install pytest
    
          # 3) Obtener BASE_URL del stack (OutputKey = BaseUrlApi)
          STACK_NAME="staging-todo-list-aws"
          BASE_URL="$(aws cloudformation describe-stacks \
            --stack-name "$STACK_NAME" \
            --query "Stacks[0].Outputs[?OutputKey=='BaseUrlApi'].OutputValue" \
            --region us-east-1 \
            --output text)"
    
          echo "BASE_URL=$BASE_URL"
          export BASE_URL

          # 4) Carpeta de reportes 
          mkdir -p reports
          # 5) Solo borramos los reportes de pytest
          rm -f reports/pytest-integration.xml

          # 6) Ejecutar tests de integración (si falla => stage rojo y aborta pipeline)
          pytest -q test/integration/todoApiTest.py --junitxml=reports/pytest-integration.xml
        '''
      }
      post {
        always {
          junit 'reports/pytest-integration.xml'
        }
      }
    }

    stage('Promote') {
      // 1) Comprobamos que estamos en la rama develop
      when { branch 'develop' }
    
      steps {
        // 2) Activo un ssh-agent temporal
        sshagent(credentials: ['github-deploykey']) {
    
          sh '''
            set -eux

            # Defino el autor del commit de merge
            git config user.name  "jenkins"

            # Defino el email
            git config user.email "pablo.conde789@comunidadunir.net"

            # Trae todas las ramas remotas (develop/master) y limpia ramas borradas
            # Esto evita merges con refs antiguas
            git fetch origin +refs/heads/*:refs/remotes/origin/* --prune

            # Crea/reescribe la rama local 'master' apuntando a origin/master
            # Jenkins suele estar en "detached HEAD", esto lo normaliza
            git checkout -B master origin/master

            # COPIA DE SEGURIDAD: guardamos el Jenkinsfile de master (CD)
            cp Jenkinsfile /tmp/Jenkinsfile.master
            
            # Merge real de develop a master
            # --no-ff fuerza un commit de merge para que quede rastro de la promoción
            git merge --no-ff origin/develop -m "Promote: merge develop -> master"
            
            # RESTAURACIÓN: volvemos a poner el Jenkinsfile de master (CD)
            cp /tmp/Jenkinsfile.master Jenkinsfile
            
            # Preparamos el Jenkinsfile restaurado para commit (si ha cambiado)            
            git add Jenkinsfile

            # Creamos un commit SOLO si había cambios pendientes en Jenkinsfile
            # Si no había cambios, git commit fallaría y con '|| true' lo ignoramos
            git commit -m "Promote: keep master Jenkinsfile (CD)" || true

            # Subimos master actualizado a GitHub
            git push origin master
          '''
        }
      }
    }

  }
}
