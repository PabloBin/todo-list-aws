pipeline {
    agent any
  
    //EVITA que Jenkins haga checkout automático en cada agente/stage
    options {
        skipDefaultCheckout()
        disableConcurrentBuilds()
        timestamps()
    }

    environment {
        SAM_ENV    = 'staging'
        STACK_NAME = 'staging-todo-list-aws'
        AWS_REGION = 'us-east-1'
        CONFIG_BRANCH = 'staging'
    }

    stages {
        stage('Get Code') {
            steps {
                // Limpiamos el workspace
                cleanWs()
                
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/develop']],
                    userRemoteConfigs: [[
                        url: 'git@github.com:PabloBin/todo-list-aws.git',
                        credentialsId: 'github-deploykey'
                    ]]
                ])
                
                sh 'echo "Branch:" && git branch -a --contains HEAD'
                sh 'echo "Last commit:" && git log -1 --oneline'
                
                sh '''
                    set -eux
                    rm -rf config-repo
                    git clone --depth 1 --branch "$CONFIG_BRANCH" \
                    https://github.com/PabloBin/todo-list-aws-config.git config-repo

                    cp config-repo/samconfig.toml samconfig.toml

                    echo "samconfig.toml (desde config-repo/$CONFIG_BRANCH):"
                    ls -la samconfig.toml
                    head -n 50 samconfig.toml || true
                '''
            }
        }
       
        stage('Static Test') {
            steps {
                sh '''
                    # -e: si algo falla, aborta
                    # -u: error si usas variables no definidas
                    # -x: muestra comandos en el log
                    set -eux
    
                    # 1) VENV reutilizable (evita reinstalar Python tools en cada build si el workspace se mantiene)
                    if [ ! -d ".venv" ]; then
                        python3 -m venv .venv
                    fi
                    . .venv/bin/activate
          
                    # 2) Dependencias necesarias para Static Test. Instalar/actualizar herramientas dentro del venv
                    pip install --upgrade pip
                    pip install flake8 bandit
    
                    # 3) Carpeta de reportes 
                    mkdir -p reports
                    # 4) Solo borramos los reportes de Flake8 y Bandit
                    rm -f reports/flake8.out reports/bandit.out
    
                    # 5) Flake8 (solo src, no bloqueante, salida estándar a fichero)
                    flake8 --exit-zero src > reports/flake8.out 2>&1
    
                    # 6) Bandit (solo src, no bloqueante, salida “custom” para que pyLint lo pinte)
                    bandit --exit-zero -r src \
                        -f custom -o reports/bandit.out \
                        --msg-template "{abspath}:{line}: [{test_id}] {msg}"
                '''
    
                // Publicación de resultados en Jenkins (sin quality gates => build SUCCESS siempre)
                recordIssues(tools: [flake8(name: 'Flake8', pattern: 'reports/flake8.out')])
                recordIssues(tools: [pyLint(name: 'Bandit', pattern: 'reports/bandit.out')])
            }
        }

        stage('Deploy') {
            steps {
                sh '''
                    set -eux
    
                    # Verificar que hay credenciales en la EC2
                    aws sts get-caller-identity

                    # Verifica SAM CLI
                    sam --version
                    
                    # Valida el template
                    sam validate --region "$AWS_REGION"

                    # Build del proyecto SAM
                    sam build
    
                    # Deploy a PRODUCTION según samconfig.toml (env: staging)
                    sam deploy \
                        --config-env "$SAM_ENV" \
                        --no-confirm-changeset \
                        --no-fail-on-empty-changeset
                '''
            }
        }

        stage('Rest Test') {
            steps { 
            
                catchError(buildResult: 'UNSTABLE', stageResult: 'FAILURE') {
                    sh '''
                        set -eux
        
                        # 1) VENV reutilizable (evita reinstalar Python tools en cada build si el workspace se mantiene)
                        if [ ! -d ".venv" ]; then
                            python3 -m venv .venv
                        fi
                        . .venv/bin/activate
        
                        # 2) Dependencias necesarias para Rest Test. Instalar/actualizar herramientas dentro del venv
                        pip install --upgrade pip
                        pip install -r src/requirements.txt
                        pip install pytest
        
                        # 3) Obtener BASE_URL del stack (OutputKey = BaseUrlApi)
                        BASE_URL="$(aws cloudformation describe-stacks \
                                    --stack-name "$STACK_NAME" \
                                    --query "Stacks[0].Outputs[?OutputKey=='BaseUrlApi'].OutputValue" \
                                    --region "$AWS_REGION" \
                                    --output text)"
        
                        echo "BASE_URL=$BASE_URL"
                        export BASE_URL

                        # 4) Carpeta de reportes 
                        mkdir -p reports
                        # 5) Solo borramos los reportes de pytest
                        rm -f reports/pytest-staging.xml

                        # 6) Ejecutar tests de integración (si falla => stage rojo y aborta pipeline)
                        pytest -q \
                            test/integration/todoApiTest.py \
                            --junitxml=reports/pytest-staging.xml
                    '''
                }
                
            }
            post {
                always {
                    junit testResults: 'reports/pytest-staging.xml', allowEmptyResults: true
                }
            }
        }

        stage('Promote') {
            when {
                expression {
                    return sh(
                        script: "git branch -r --contains HEAD | sed 's/^[ *]*//' | grep -qx 'origin/develop'",
                        returnStatus: true
                    ) == 0
                }
            }
        
            steps {
                // 2) Activo un ssh-agent temporal
                sshagent(credentials: ['github-deploykey']) {
                    sh '''
                        set -eux
        
                        # Defino el autor e email del commit de merge
                        git config user.name  "jenkins"
                        git config user.email "pablo.conde789@comunidadunir.net"

                        # Trae todas las ramas remotas (develop/master) y limpia ramas borradas
                        # Esto evita merges con refs antiguas
                        git fetch origin +refs/heads/*:refs/remotes/origin/* --prune
        
                        # Nos ponemos en master limpio
                        git checkout -B master origin/master
        
                        # Intentamos merge normal
                        if ! git merge --no-ff origin/develop -m "Promote: merge develop -> master"; then
                            echo "Merge had conflicts. Auto-resolving JENKINSFILE by keeping master version..."
        
                            # Si el conflicto es en JENKINSFILE, forzamos quedarnos con el de master (ours)
                            git checkout --ours JENKINSFILE || true
                            git checkout --ours JENKINSFILE_agentes || true
                  
                            git add JENKINSFILE || true
                            git add JENKINSFILE_agentes || true
                  
                            # Si hubiera quedado el repo aún en estado conflictivo por otras cosas, fallará aquí (correcto)
                            git commit -m "Promote: merge develop -> master (keep master JENKINSFILE)"
                        fi
        
                        # Empujamos master
                        git push origin master
                    '''
                }
            }
        }
    }
    post { 
        always { 
            cleanWs() 
        } 
    }
}
